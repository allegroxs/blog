# Digital IC exam preparation
## General
- 三个Domain
  - Structural
  - behavior
  - physical
- 层级
  - 系统级
  - 行为级：算法
  - RTL: Register transfer level
  - 门级
- 综合：抽象等级向下，Solution数量变多。系统级-应用级-高级（HLS）-逻辑级-物理级。
- 三个墙
  - Frequency wall
  - memory wall
  - power wall

- cmos管画法
- RTL级别画法。四分频电路=时间变成四倍，用两个D-FF
- 看RTL模型判断功能
## Frontend/hdl
- Coding Style Check
  - CDC(Clock Domain Cross)、Lint 等问题。
- DFT(Design For Test) 为了保证芯片内部的制造缺陷尽量能够被检测到，通过在电路中插入扫描链（Scan Chain）的方式，测试 IC 在生产制造过程中是否出现问题。加入 DFT 会增加 20%~30%的面积。

- Verilog 书写规范  在编程时多注意以下几点，也可以避免大多数的竞争与冒险问题。
1）时序电路建模时，用非阻塞赋值。
2）组合逻辑建模时，用阻塞赋值。
3）在同一个 always 块中建立时序和组合逻辑模型时，用非阻塞赋值。
4）在同一个 always 块中不要既使用阻塞赋值又使用非阻塞赋值。
5）不要在多个 always 块中为同一个变量赋值。
6）避免 latch 产生。

- 竞争 competition：不会产生错误输出的称为非临界竞争，否则为临界竞争。冒险 hazard，尖峰信号、毛刺，一定有竞争
  - 判断方法： 在逻辑表达式，保持一个变量固定不动，将剩余其他变量用 0 或 1 代替，如果最后逻辑表达式能化简成A&A'或A|A'，则有。
  - 消除方法
  - 1. 增加滤波电容，滤除窄脉冲。此种方法需要在输出端并联一个小电容，将尖峰脉冲的幅度削弱至门电路阈值以下。
  - 2. 修改逻辑，增加冗余项。利用卡诺图，在两个相切的圆之间，增加一个卡诺圈，并加在逻辑表达式之中。如下图所示，对数字逻辑 Y = A'B' + AC 增加冗余项 B'C，则此电路逻辑可以表示为 Y = A'B' + AC + B'C。此时电路就不会再存在竞争与冒险。
  - 3. 使用时钟同步电路，利用触发器进行打拍延迟clap_delay。同步电路信号的变化都发生在时钟边沿。对于触发器的 D 输入端，只要毛刺不出现在时钟的上升沿并且不满足数据的建立和保持时间，就不会对系统造成危害，因此可认为 D 触发器的 D 输入端对毛刺不敏感。 利用此特性，在时钟边沿驱动下，对一个组合逻辑信号进行延迟打拍，可消除竞争冒险。延迟一拍时钟时，会一定概率的减少竞争冒险的出现。实验表明，最安全的打拍延迟周期是 3 拍，可有效减少竞争冒险的出现。
  - 4.采用格雷码计数器

### Verilog 语法
- output reg for squencial logic; input only wire in a module.
- There are three types of assignments in Verilog:
  1. Continuous assignments (assign x = y;). Can only be used when not inside a procedure ("always block").
  2. Procedural blocking assignment: (x = y;). Can only be used inside a procedure.
  3. Procedural non-blocking assignment: (x <= y;). Can only be used inside a procedure.
  - assign with  `=`; combinational blocks with `=`, bcause it means sentences in order.
  - Squencialblocks with `<=`
- Selection
  1. case and endcase: no punctuation; default
  2. casez and endcase: casez treats bits that have the value z as don't-care in the comparison; A case statement behaves as though each item is checked sequentially (in reality, a big combinational logic function)(The first match is chosen)
  3. There is also a similar casex that treats both x and z as don't-care. I don't see much purpose to using it over casez.
  The digit ? is a synonym for z. so 2'bz0 is the same as 2'b?0
- always@(posedge clock or negedge rst)
- always@(*)
- 4'b1111 equals to 4'd15
- shift: <<

- 不可综合
  - 时延 #
  - 

### 验证
- testbench
  - DUT
  - clock/reset
  - simulator
  - monitor
  - checker
- MCDF
  - slave chain
  - arbiter
  - register
  - formatter


## Backend
- Synthesys = Domain Transfer + Refinement + Optimisation
  - Refinement: Higher to Lower Abstraction
- Standard cell
  - A cell library holds relevant information about cells. For instance, name, functionality, delays, resistance, capacitance, layout, area, pin topology etc. 
  - All cells in a library have same standardized layouts, i.e., all cells have the same height.

- SDF=standard delay format：SDF文件（Standard Delay File）提供了延迟信息表示的标准ASCII文件格式，Forward-Annotation of Timing Constraints for Design Synthesis 
- syn/db: gate-level netlist, generated by synthesys
- syn/rpt: 
- STA: Static Timing Analysis 输出SDF，timing ECO 文件
  - Analysis is the opposite of synthesis
  - 从逻辑综合开始，基本上每做一步大的调整，都会完成一次 STA 分析，以保证每步都能实现时序收敛。通常设计中会存在大量的违例路径，STA 要修大量的 setup、hold 等，如何修这些违例，可以体现工作经验的重要性。此外，如果是前端修 timing 违例，一般会修的很快，但是会带来一个重大的问题，代码被前端修改后是否存在新的 bug，还需重新仿真确认，仿真会消耗掉数以月计的时间，所以除非万不得已，不会找前端修 timing。STA 主要是在时序上对电路进行验证，检查电路是否存在建立时间（setup time）和保持时间（hold time）的违例（violation）。而形式验证是从功能上对综合后的网表进行验证。常用的就是等价性检查（LEC）方法，以功能验证后的 HDL 设计为参考，对比综合后的网表功能，他们是否在功能上存在等价性。静态时序分析和形式验证出现在设计流程中前后端过程，有一些地方在前端中没有提到，应该是在后端当中比较重要，作为验证设计工作的一部分，在前端中也加入静态时序分析和形式验证可以提高设计的可靠性。


- 亚稳态
  - 违反了建立时间、保持时间
  - 降低系统时钟频率
  - 用反应更快的 FIFO 引入同步机制，防止亚稳态传播（可以采用前面说的加两级触发器）。异步信号同步化（两级触发器）;
  - 采用 FIFO 对跨时钟域数据通信进行缓冲; 
  - 对复位电路采用异步复位、同步释放处理 改善时钟质量，用边沿变化快速的时钟信号
- 跨时钟域处理

- 时序约束主要包括周期约束，偏移约束，静态时序路径约束三种
- 2.1 静态时序分析
   静态时序分析（static timing analysis，STA）是遍历电路存在的所有时序路径，根据给定工作条件（PVT）下的时序库.lib 文件计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足约束要求，根据最大路径延时和最小路径延时找出违背时序约束的错误。
   2.1.1 静态时序分析的优点
   不需要给输入激励；
   几乎能找到所有的关键路径（critical path）；
   运行速度快；
   2.1.2 静态时序分析的缺点
   只适用同步电路；
   无法验证电路的功能；
   需要比较贵的工具支持；
   对于新工艺可能还需要建立一套特征库，建库的代价可能要几百万。
- 动态时序分析（dynamic timing analysis，DTA）通常是所有的输入信号都会给一个不同时刻的激励，在 testbech（.sp 或者.v）中设置一段仿真时间，最后对仿真结果进行时序和功能分析。 这里的仿真可以是门级或者晶体管级，包括 spice 格式和 RTL 格式的网表。

门控时钟？
芯片功耗组成中，有高达 40%甚至更多是由时钟树消耗掉的。这个结果的原因也很直观，因为这些时钟树在系统中具有最高的切换频率，而且有很多时钟 buffer，而且为了最小化时钟延时，它们通常具有很高的驱动强度。此外，即使输入和输出保持不变，接收时钟的触发器也会消耗一定的功耗。而且这些功耗主要是动态功耗。那么减少时钟网络的功耗消耗，最直接的办法就是如果不需要时钟的时候，就把时钟关掉。这种方法就是大家熟悉的门控时钟：clock gating。(电路图中看到的 CG cell 就是门控时钟了)。

注意要点：通常情况下，不建议使用门控时钟，因为门控时钟由组合逻辑产生，那么它本身就潜伏了组合逻辑的最大隐患——竞争和险象，所以门控时钟信号很容易产生毛刺，而寄存器等存储单元对时钟信号的边沿都非常敏感，因此具有毛刺的时钟会造成时序逻辑的不稳定。


## Hardware
- 建立时间：时钟信号上升沿到来之前，信号保持稳定的时间；保持时间：时钟信号到来之后，信号需要保持稳定的时间
recovery time: 复位信号中类似于同步时钟的setup time
removal time：复位信号中类似于同步时钟的hold time

- TTL: Transistor-Transistor Logic 逻辑门电路
- MOS:Complementary Metal Oxide Semiconductor. TTL以速度见长，CMOS以功耗低而著称，其中CMOS电路以其优良的特性成为目前应用最广泛的集成电路

- WDT 看门狗时钟


1. 门阵列（Gate Array）
是指在硅片上制成标准的逻辑门，它是不封装的半成品，生产厂家可根据用户要求，在掩膜中制作出互连的图案（码点），最后封装为成品，在提供给用户。
2. 标准单元（Standard Cell）
是指由集成电路厂家将预先设置好，经过测试且具有一定功能的逻辑块作为标准单元存储在数据库中，包括标准的TTL、CMOS、存储器、微处理器及I/O电路的专用单元阵列。设计人员在电路设计完成后，利用CAD根据在版图一级完成与电路一一对应的最终设计。标准单元设计灵活，功能强，但涉及和制造周期较长，开发费用也较高。
3. 可编程逻辑器件（Programmable Logic Device）
属于ASIC的一个重要分支，是集成电路厂家作为一种通用性器件生产的半定制电路，用户可通过对器件编程实现所需要的逻辑功能。PLD是用户可配置的逻辑器件，成本较低，使用灵活，设计时发展非常迅速。

## flow

ASIC


FPGA


# Courses and labs

## IL2203 Hardware description languages
It is a CISC, *with* a microcontroller ROM.
1. ALU
   1. Opcode
2. Register File
   1. Test: patterns like “1010101” followed by “0101010” also checks if the bits are leaking to their neighbors
3. Datapath
   1. Create a clock divider component. It should divide the 100 MHz clock on the board to an internal clock of approximately 1 Hz. The easiest way to achieve that is to make an incrementer (add 1), and use the MSB of it as the Clk output. 
   2.  add-1 test
4. FSM
   1. a Program Counter and a bypass mux for jump/branch instructions. The Program counter is either part of the registers in the register file (typically the last one), but it can also be a separate PC register, external to the register file. In our case, we will not be incrementing the PC externally, but use the last register (reg 7 in our case) for the PC
   2.  Microcontroller ROM for issuing microcode instructions
5. cpu
   1. Complete the *Microcontroller FSM* and add a R_Wn signal (or use two separate signals, RDEN and WREN) for controlling accesses to an external external memory. 
   2. ROM.  We complete the *Microcontroller ROM* and include R/W_n signals to control reading/writing from/to external memories. Modelsim will convert your assembly program to hex-codes. Look on the RAM signal in the simulation window of Modelsim when you test the fake memory architecture, and write down the hex-codes in the memory.mif file. From now on, you should use the generated memory in your simulations so you get the memory latency right. 
   1. We also build a *General Purpose IO* unit for writing data to LEDS, and write the *program (assembly code)* that should be stored in the external memory. We then build a *testbench* to run the system with the assembly code in it to test it
   2. Finally, we download the Microcontroller component on the prototype FPGA board and verify that it works.



## IL2230 MLP
The artificial neuron model is mathematically a weighted sum of inputs followed by a nonlinear transformation, as shown in Figure 2. Here the nonlinear function f can be in different forms such as the step function, sigmoid, hyperbolic tangent, ReLU etc. Despite its simplicity, neuron is the building block of neural networks. It is the “brick” of the deep learning “house”. Therefore, to design efficient hardware accelerator for neural networks, it is essential to understand the hardware design organizations and their tradeoffs of the basic unit, neuron

1. Serial-semi-parallel neuron
   1. One-neuron design. Generic M × N MLP modeling (M layers, N neurons per layer) with one single neuron unit (M, N are generic parameters). The control path takes care of the repetitive computation using the single neuron to achieve the desired functionality of the neural network. This is one extreme case of fully serial implementation at the neuron level
   2. Semi neuron: N-neuron design. Generic M × N MLP modeling (M layers, N neurons per layer) with N neuron units (M, N are generic). This can be viewed as another extreme that uses a parallel architecture (as many per-layer neurons as needed). Still you need to consider how to re-use the one-layer neurons to implement the M layers of neuron computations
   3. parallel neuron
2. Nonlinear function
   1. relu
   2. sigmoid: n-segments fitting
3. DC_shell
   1.  Wire_load_mode is top. 
   2.  Operating condition is NCCOM from tcbn90gtc.
   3.  CTS
   4.  Power optimization
       1.  Clock gate
       2.  Operand isolation


## IL2225
After doing the IL2230 lab, go on:
Operating condition is NCCOM from tcbn90gtc, means: 

Type | Voltage | Temperature | Process
---|---|---|---
Low Temperature(LTCOM) | VDD + 10% | -40oC | Fast-Fast
Best Case(BCCOM) | VDD + 10% | 0oC | Fast-Fast
Typical Case(NCCOM) | VDD | 25oC | Typical-Typical
Worst Case(WCCOM) | VDD - 10% | 125oC | Slow-Slow

synopsys_dc.setup
```shell
set SynopsysHome /afs/ict.kth.se/pkg/synopsys/designcompiler/J-2014.09
set search_path "/afs/ict.kth.se/pkg/synopsys/designcompiler/J-2014.09/libraries/syn\
                 /afs/it.kth.se/pkg/synopsys/extra_libraries/standard_cell/TSMC/tcbn90g_110a/Front_End/timing_power/tcbn90g_110a/"

set cache_read  "/tmp"
set cache_write "/tmp"

#SYNTH VHDL FILE DEFAULTS
set view_read_file_suffix    "db sdb edif sedif vhd vhdl st script"
set view_analyze_file_suffix "v vhd vhdl"
set template_parameter_style "%d"; # Limits the lenght of comp. names

set link_path       ${search_path}
set target_library  "tcbn90gtc.db"
set symbol_library  "tcbn90g.sdb"

set synthetic_library "standard.sldb\
                       dw_foundation.sldb";
set link_library      "* ${target_library}"

define_design_lib WORK -path "./dc_work"
```

counstraint.sdc
- set_units
- create_clock period
- set_false_path reset(false path?)
- set_lead

SDF
This file will be used to back annotate the delays of the circuit in our gate-level simulation.

DDC: saving the design after synthesis(*compile) 
V: saving the gate level netlist

WIRE LOAD MODEL & WIRE LOAD MODE
http://www.vlsi-expert.com/2012/03/delay-wire-load-model-static-timing.html


### Gate level simulation
- Value Change Dump File (VCD File)  This VCD file will then be used to accurately estimate the power in our FIR Filte
- Synopsys does not support VCD file format and instead supports Switching Activity Information Format. To use this technique in Synopsys, either we need to generate saif file or we can convert a VCD file into a saif format file 

### Power saving
1. Clock gating
2. Operand Isolation

### Hierarchal Bottom Up Synthesis

### Physical Design
Place and Route with Innovus
- Floorplan
- Power and ground routing
- Placement of the design
- Clock tree synthesis
- Routing
- Adding Filler cells and metal
- GDS File export
- Verilog netlist expor
- Calculating and exporting delay


# Embedded software

# IL2206
toy cruise control application using the DE2/DE-115 board.

input:
• Engine (ON/OFF). The engine is turned on, in case the signal ENGINE is active. The engine can only be turned off, if the speed of the car is 0
• Cruise Control (ON/OFF). The cruise control is turned on, if
  - the signal CRUISE_CONTROL is activated
  - the car is in top gear (TOP_GEAR is active)
  - the velocity is at least 20 m/s
  - the signals GAS_PEDAL and BRAKE_PEDAL are inactive.
• Gas Pedal (ON/OFF). The car shall accelerate, if the signal GAS_PEDAL is active. The cruise control shall be deactivated, if GAS_PEDAL is active.
• Brake (ON/OFF). The car shall brake, when the signal BRAKE is active. Also the cruise control shall be deactivated, if the signal BRAKE is activated.
• Gear (HIGH/LOW). The car has two different gear positions (high, low) indicated by the signal TOP_GEAR. If TOP_GEAR is active then the gear position is high, otherwise low. The cruise control is deactivated, when the gear position is moved to low.

In the skeleton program, the control task uses a constant throttle of 40. The task VehicleTask
implements the behavior of the car and its functionality shall not be changed
during this laboratory. The only permitted code modification in VehicleTask
is the replacement of the timer (see Task 4.2).

- Use Soft Timers to Implement Periodic Tasks
  - The skeleton program uses the statement `OSTimeDlyHMSM` to implement periodic tasks, which will not give an exact period. 
  - `OSTmrCreate` in µC/OS-II Reference Manual, Chapter 16.
  - I/O-Tasks: 
    - Create the tasks ButtonIO and SwitchIO, which read the buttons and switches on the DE2-board periodically. 
    - The task SwitchIO creates the signals ENGINE and TOP_GEAR
    - the task ButtonIO creates the signals CRUISE_CONTROL, GAS_PEDAL and BRAKE_PEDAL.
  - Control Law:
     -  Implement the control law in the ControlTask so that it fulfills the specification from Section 4. Note that the braking functionality is implemented inside the VehicleTask and requires a message to be sent, whereas the ControlTask sets the throttle. For this example, the toy car has some hardwired safeguard circuitry which disables the car’s throttle whenever the brakes are activated. Furthermore, you can assume that the dynamics of the car is of a simple mass moving through the profile given subject to linear wind resistance.
     -  The control law shall react according to the state of the buttons and switches. When the cruise control is activated, the current velocity shall be maintained with a maximum deviation of
  - Watchdog
    - a watchdog task and an overload detection task 
    - The overload detection task shall report to the watchdog with an ’OK’ signal, when there is no overload condition, i.e. the system’s utilisation is less than 100%. 
    - In case the watchdog task does not receive the ’OK’ signal during a specified interval, the watchdog should infer that the system is overloaded, i.e. reached 100% utilisation, and it shall consequently issue an overload warning message. 
    - Add another task to impose an extra load on the system. It shall be possible to dynamically adjust the amount of processing time that the task utilizes. To set the utilization, the switches SW4 to SW9 shall be used.
    - The switch pattern shall be interpreted as a binary number (with SW4 as the lowest bit), i.e., 2^6 values can be represented. The utilization shall be adjustable in 2% steps. Everything higher than 100% (i.e., all numbers above 1)  shall be considered as 100% utilization. Hint: think about the system’s hyperperiod while interpreting the utilisation ratio “x%
  
```
                ┌─────────┐
                │         │
                │         │
                │         │
                └─────────┘
                     ▲                                   ┌────────────┐
                     │                                   │            │
                     │                                   │   Button   │
                     │                                   │     IO     │
                     │                                   │            │
                     │                                   └────────────┘
                ┌────┴────┐
                │         │
                │         │
                │         │
                └─────────┘
    ┌────────────┐              ┌──────────┐             ┌────────────┐             ┌──────────────┐
    │            │              │          │             │            │             │              │
    │            │              │          │             │            │             │              │
    │            │              │          │             │            │             │              │
    │            │              │          │             │            │             │              │
    └────────────┘              └──────────┘             └────────────┘             └──────────────┘
```

- Working experience
GUI in C++

OpenCL


- TOF calibration



# Machine Learning

## IL2230

## IL2233



Working experience

